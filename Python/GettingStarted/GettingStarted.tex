\lab{Python}{Getting Started}{Getting Started}
\objective{To introduce basic coding procedures and objects usage in Python.}
\label{lab:Essential_Python}

\section*{Prerequisites}
Let's talk about what you need to get started.

Python 2.7 is required for the labs in this text and can be downloaded and 
installed from \url{http://www.python.org/}. Although later editions of 
Python are available, they do not have many of the features we are interested in. 

There are many IDEs (Integrated Development Environments) and text editors freely 
available. We recommend using the IPython Notebook (a web-based, interactive, 
computational environment) that allows for input and output to be easily 
and aesthetically displayed in a single environment. 

To begin, open your command line and change directories to your desired location 
(typically where you want your files to be saved). It is important to be aware 
of your working directory. Your operating system will determine how commands are dictated, 
but changing directories is done using the following command.
\begin{lstlisting}
cd <location>
\end{lstlisting}
Now, run the following command to start running a notebook server.
\begin{lstlisting}
ipython notebook
\end{lstlisting}

For more information on downloading and installing various packages, please 
reference the Appendix. 


\section*{Python}
Python is a powerful general-purpose programming language. It is an interpreted
language and can even be used interactively. 
It is quickly gaining momentum as a tool in scientific computing and has several 
very nice key features:
\begin{itemize}
\item Clear, readable syntax
\item Full object orientation
\item Complete memory management (via garbage collection)
\item High level, dynamic datatypes
\item Extensibility via C
\item Ability to interface to other languages such as R, C, C++, and Fortran
\item Embeddability in applications
\item Portability across many platforms (Linux, Windows, Mac OSX)
\item Open source

\end{itemize}
In addition to these, Python is freely available and can also be freely distributed.

\section*{Learning Python}
There are many well written introductions to the Python language.
We recommend you review the following sources if you are learning Python for the
first time.

\begin{itemize}
\item Official Python Tutorial (Start with Chapter 3): 
\url{http://docs.python.org/tutorial/index.html} 
\item SciPy Lecture Notes: \url{http://scipy-lectures.github.com/}
\item Dive Into Python 3: \url{http://getpython3.com/diveintopython3/}
\item Python Style Guide: \url{http://www.python.org/dev/peps/pep-0008/}
\end{itemize}

The following examples and problems highlight important functionality
and syntax in Python, but are by no means comprehensive.
As you familiarize yourself with Python and begin to work through the problems,  
we strongly suggest you read the following:
\begin{enumerate}
\item Chapters 3, 4, and 5 of the Official Python Tutorial \\
        (\url{http://docs.python.org/2/tutorial/introduction.html}).
\item Section 1.2 of the SciPy Lecture Notes \\
        (\url{http://scipy-lectures.github.io/}).
\item PEP8 - Python Style Guide \\
        (\url{http://www.python.org/dev/peps/pep-0008/}).
\end{enumerate}


As you progress through this lab we recommend that you verify and work 
through the examples in your command line. 
To do so, open your command line and run the following command: 
\begin{lstlisting}
ipython
\end{lstlisting}
You are now in the interactive IPython terminal.
However, it is suggested you save your work for the formal problems in the 
IPython Notebook or a text editor. 

Python is a high-level programming language with powerful capabilities. 
It has many standard data types including numbers, strings, lists, sets, and dictionaries. 

\subsection*{Numbers}
\begin{example}
As its name suggests, number data types store numeric values. 
It is an immutable data type meaning that changing the value results in a 
newly allocated variable. It cannot be modified after creation. 
There are four different numerical types: \li{int}, \li{long}, 
\li{float}, and \li{complex}

\begin{lstlisting}

In [1]: # Comments will frequently be provided in this form. 

In [2]: '''
   ...: It is also possible to use multiline strings as comments. 
   ...: These are enclosed by 3 single (or double) quotations at 
   ...: the beginning and end. 
   ...: '''
Out[2]: '\nIt is also possible to use multiline strings as comments. \nThese are enclosed by 3 single (or double) quotations at \nthe beginning and end. \n'

In [3]: # Python can be used as a simple calculator.

In [4]: 9*8 + 4*5
Out[4]: 92

In [5]: # Integer division returns the floor.

In [6]: 100/3
Out[6]: 33

In [7]: # Use floating points to ensure the floating point operand. IMPORTANT!!!

In [8]: 100/3.0
Out[8]: 33.333333333333336

In [9]: # Use variables to reserve locations in memory to store values.

In [10]: x = 12

In [11]: y = 2 * 6

In [12]: # It is possible to check equality between two variables.

In [13]: x == y
Out[13]: True

In [14]: # It is also possible to assign multiple values to multiple variables.

In [15]: a, b, c = 1, 2, 3

In [16]: (a + b)**c
Out[16]: 27

\end{lstlisting}
\end{example}

\begin{problem}
It may be necessary to look up the formal documentation, but be sure to 
answer the following questions with the best answer:

\begin{enumerate}

\item Why does \li{7/3} return \li{2} in Python 2? 
\item What are the two ways to create a complex number? 
How do you extract just the real part and just the imaginary part?
\item How would you cast an integer as a float?
\item Is there a way to explicitly express integer division when using floats?
\end{enumerate}
\end{problem}

\subsection*{String}
\begin{example}

The \li{string} module in Python is identified as an ordered sequence of characters 
between quotation marks. Those quotation marks may be single or double quotes. 
Strings can be concatenated using the \li{+} operator and sliced using \li{[ ]}.
The index of a string starts with zero and goes to -1 at the end. Keep in mind 
that the stop index given is never reached. 
The \li{string} datatype is immutable meaning it cannot be modified in place once 
it has been allocated. 

\begin{lstlisting}

In [1]: str1 = "I love"

In [2]: str2 = "the ACME program"

In [3]: str3 = "puppies and baby ducks"

In [4]: str4 = "sleeping"

In [5]: # The + operator concatenates strings.

In [6]: str1 + " " + str2 + "!"
Out[6]: 'I love the ACME program!'

In [7]: # To slice, [start:stop:step].

In [7]: my_string = "T" + str2[1:4] + str3[:9] + "re " + str4 + "."

In [8]: my_string
Out[8]: 'The puppies are sleeping.'

In [9]: my_string[0:-1:2]
Out[9]: 'Teppisaesepn'

\end{lstlisting}
\end{example}

\begin{problem}
Answer the following questions with the best answer:

\begin{enumerate}

\item What does it mean for \li{string} to be an immutable object? 
\item What happens in \li{my_string[::3]} and \li{my_string[27:0:-1]} provided 
that \li{my_string = "I love the new ACME program\!"}? 
\item How can you access the entire string in reverse?

\end{enumerate}
\end{problem}

\subsection*{Lists}
\begin{example}

The \li{list} data type is the most versatile. 
It contains comma separated values (csv) enclosed within square brackets. 
It is a mutable sequence allowing in-place modification after creation. 
The values within a list can be different data types and are accessed using the 
slice operator (just like strings). 
There are many methods available to the \li{list} data type. 
Some are implemented below. 

\begin{lstlisting}

In [1]: my_list = ["Remi", 21, "02/05", 1993]

In [2]: my_list[0]
Out[2]: 'Remi'

In [3]: my_list[2] = "February 05"

In [4]: # Append adds an item to the end of your list.

In [5]: my_list.append("student")

In [6]: # The insert method takes an item and inserts it at a given position. 

In [7]: my_list.insert(0, "female")

In [8]: # The remove method takes an item and removes it from your list.

In [9]: my_list.remove("student")

In [10]: # Lists can also be sorted in place. 

In [11]: my_list.sort()

In [12]: my_list
Out[12]: [21, 1993, 'February 05', 'Remi', 'female']

In [13]: # Lists can also be reversed.

In [14]: my_list.reverse()

In [15]: # List comprehensions provide a concise way to create lists. 

In [16]: [x**2 for x in range(10)]
Out[16]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

\end{lstlisting}
\end{example}

\begin{problem}
Answer the following questions with the best answer:

\begin{enumerate}

\item What is the difference between mutable and immutable objects?
\item If \li{my_list = ["mushrooms", "rock climbing", 1947, 1954, "yoga"]}
\begin{enumerate}

	\item How would you access "yoga"? 
	\item How would you view a copy of \li{my_list}?
	\item How would you clear the entire list? 
	\item How would you find the length? 
	\item How would you assign "mushrooms" (first entry) and "rock climbing" (second entry) 
	of \li{my_list} to "Peter Pan" and "camelbak"? 
	(This should be done in one line of code and is known as a slice assignment)
	\item How would you add "Jonathan, my pet fish" to the end of the list?

\end{enumerate}
\item What sequence of commands would you use to implement the following?

\begin{enumerate}
\item Create an empty list. 
\item Add 5 integers to your list. 
\item Cast the integer at index 3 as a float.
\item Remove the integer at index 2. 
\item Sort your list backwards.

\end{enumerate}
\end{enumerate}
\end{problem}


\subsection*{Sets}
\begin{example}

The \li{set} data type is an unordered collection of distinct objects. 
It is a mutable object that allows contents to be added and removed after creation. 
Like mathematical sets, python supports operations like union, intersection, 
difference, and symmetric difference. 

\begin{lstlisting}

In [1]: gym_members = set(["Doe, John", "Smith, Jane", "Brown, Bob", "Jones, Sally"])

In [2]: gym_members
Out[2]:{'Brown, Bob', 'Doe, John', 'Jones, Sally', 'Smith, Jane'}

In [3]: gym_members.add("Lytle, Josh")

In [4]: gym_members.add("Doe, John")

In [5]: gym_members
Out[5]: {'Brown, Bob', 'Doe, John', 'Jones, Sally', 'Lytle, Josh', 'Smith, Jane'}

In [6]: library_members = set(["Lytle, Jane", "Henriksen, Ian", "Smith, Jane", "Grout, Ryan"])

In [7]: library_members.discard("Smith, Jane")

In [8]: library_members.add("Lytle, Josh") 

In [9]: library_members
Out[9]: {'Grout, Ryan', 'Henriksen, Ian', 'Lytle, Jane', 'Lytle, Josh'}

In [10]: inter = set.intersection(gym_members, library_members)

In [11]: inter
Out[11]: {'Lytle, Josh'}

In [12]: library_members & gym_members
Out[12]: {'Lytle, Josh'}

\end{lstlisting}
\end{example}

\begin{problem}
Answer the following questions with the best answer:
\begin{enumerate}
\item What are the two ways to create sets? Which way must be used to 
create an empty set?
\item How would you take the union of sets?
\item How are sets indexed?

\end{enumerate}
\end{problem}

\subsection*{Dictionaries}
\begin{example}

The \li{dict} data type is an unordered standard mapping type 
organized by key:value pairs. They are indexed by keys. 

\begin{lstlisting}

In [1]: tel = {"accounting":4234, "admissions": 2507, "financial aid": 4104, "marriott": 4121, "math": 2061, "visual arts" : 7321} 

In [2]: tel["math"]
Out[2]: 2061

In [3]: tel.keys()
Out[3]: 
['visual arts',
 'admissions',
 'financial aid',
 'accounting',
 'marriott',
 'math']
 
\end{lstlisting}
\end{example}

\begin{problem}
Answer the following questions with the best answer:
\begin{enumerate}
\item What are the two ways to create dictionaries? Which way must be used to
create an empty dictionary?
\item Just as in Example 1.3 above created a list using list comprehension, 
create a dictionary using dictionary comprehension to produce the following output:

\begin{lstlisting}
{2: 4, 4: 16, 6: 36, 8: 64, 10: 100}
\end{lstlisting}

(Note that because dictionaries are unordered sets, your output need not match the 
order of the output displayed above).
\item How do you delete a key:value pair?
\item How do you access a list of all the values in your dictionary? 

\end{enumerate}
\end{problem}


\section*{Control Flow Tools}

Control flow blocks control the order in which your code is executed.
Python supports the usual control flow statements used in other languages
including the \li{while} loop, the \li{if} statement, the \li{for} loop, 
and function definition. 

\subsection*{the while loop}
\begin{example}

The \li{while} loop executes a command while the given condition holds. 
Be cautious of creating an infinite loop in which the condition is always true.

\begin{lstlisting}

In [1]: # The Fibonacci series can be formulated using a while statement. 

In [2]: a, b = 0, 1

In [3]: while b < 10:
   ...:     print a
   ...:     a, b = b, a+b
   ...:     
0
1
1
2
3
5

\end{lstlisting}
\end{example}

\subsection*{the if statement}
\begin{example}

The \li{if} statement behaves as expected: if the condition holds, execute the 
following indented code. Note that the indentation is important to Python. 
\li{elif} is short for else if and can be used multiple times or not at all. 
The \li{else} keyword may only be used once at the end (requires no condition), 
but may also be omitted. 

\begin{lstlisting}

In [1]: food = "bagel"

In [2]: if food == "apple":
   ....:     print "72 calories"
   ....: elif food == "banana":
   ....:     print "105 calories"
   ....: elif food == "egg":
   ....:     print "102 calories"
   ....: elif food == "oatmeal":
   ....:     print "147 calories"
   ....: elif food == "pizza":
   ....:     print "298 calories"
   ....: else: 
   ....:     print "calorie count unavailable"
   ....:     
calorie count unavailable
   
\end{lstlisting}
\end{example}

\subsection*{the for loop}
\begin{example}

The \li{for} loop iterates over the items in any sequence. 
The \li{range} function is typically used to generate lists that allow iteration 
over a sequence of numbers. Note that the given stop value is never attained. 

\begin{lstlisting}

In [1]: my_list = ["Henry XXI", "beta fish", "asparagus", 4]

In [2]: for i in range(len(my_list)):
   ...:     my_list.append(i)
   ...:     

In [3]: my_list
Out[3]: ['Henry XXI', 'beta fish', 'asparagus', 4, 0, 1, 2, 3]

\end{lstlisting}
\end{example}


\subsection*{function definition}
\begin{example}

The \li{def} keyword allows for a function definition. It is followed by 
the function name and a parenthesized list of formal parameters.
The formal parameters are given variables the function requires. 
Once again, indentation is important. 

\begin{lstlisting}

In [1]: def fibonacci(n):
   ...:     a, b = 0, 1
   ...:     while a < n:
   ...:         print a, b
   ...:         a, b = b, a+b
   ...:         

In [2]: fibonacci(10)
0 1
1 1
1 2
2 3
3 5
5 8
8 13

\end{lstlisting}

The order in which you enter in your parameter values when calling your function corresponds to the order in which the parameters were defined. One way around this is to use keyword arguments which take the form of ``keyword = value". The value you give when defining the function is the default value.

\begin{lstlisting}

In [1]: # Defining function with keyword arguments.

In [2]: def function_name(a, b = "Default value: string, number, etc.", c = 2):
    		print a
    		print b
    		print c

In [3]: # Calling function and only defining 'a'.

In [4]: function_name(1)
1
Default value: string, number, etc.
2

In [5]: # Defining 'a' and redefining 'c'.

In [6]: function_name(1, c = 3)
1
Default value: string, number, etc.
3

In [7]: # This works as well

In [8]: function_name(c = 3, a = 4)
4
Default value: string, number, etc.
3

\end{lstlisting}

The general pattern for defining parameters should start with defining the formal parameters (`a' in the last example) and then keyword arguments if any.

Many times when looking at the documentation of a function or when creating your own function you will see the following:

\begin{lstlisting}
def function(*args, **kwargs):
\end{lstlisting}

The parameters *args and **kwargs simply provide a way, when calling the function, to input an indefinite amount of parameters.  The term *args stands for arguments and **kwargs for keyword arguments.  

\begin{lstlisting}

\end{lstlisting}

\end{example}

\begin{problem}
Answer the following questions with the best answer:

\begin{enumerate}
\item Explain what the print and return statements do. How are they different?
\item What is wrong with the following code?
\begin{lstlisting}
Grocery List = ['pineapple', 'orange juice', "avocados", "pesto sauce"]
for i in range(Grocery List)
if i % 2 = 0
print i, Grocery List(i)
\end{lstlisting}
provided you want the following output:
\begin{lstlisting}
0 pineapple
2 avocados
\end{lstlisting}
Note that this code may contain one error, many errors, or no errors at all.

\end{enumerate}
\end{problem}



\section*{Specifications}
We suggest that you submit your \li{solutions.py} file using the following format.
\begin{lstlisting}
# Problem 1
'''
1. 
2. 
3. 
4.  
'''

# Problem 2	
'''
1. 
2.
3.  
'''

# Problem 3
'''	
1.
2.
3.
'''

# Problem 4
'''
1. 
2. 
3. 
'''

# Problem 5
'''
1. 
2. 
3.
4.  
'''

# Problem 6
'''
1. 
2.  
'''
\end{lstlisting}	
